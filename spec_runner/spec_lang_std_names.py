from __future__ import annotations

from typing import Final


SPECIAL_FORMS: Final[set[str]] = {"if", "let", "fn", "call", "var", "lit"}


FLAT_TO_STD: Final[dict[str, str]] = {
    "subject": "std.core.subject",
    "contains": "std.string.contains",
    "starts_with": "std.string.starts_with",
    "ends_with": "std.string.ends_with",
    "regex_match": "std.string.regex_match",
    "matches": "std.string.matches",
    "eq": "std.logic.eq",
    "neq": "std.logic.neq",
    "equals": "std.logic.equals",
    "in": "std.collection.in",
    "includes": "std.collection.includes",
    "lt": "std.logic.lt",
    "lte": "std.logic.lte",
    "gt": "std.logic.gt",
    "gte": "std.logic.gte",
    "add": "std.math.add",
    "sub": "std.math.sub",
    "mul": "std.math.mul",
    "div": "std.math.div",
    "mod": "std.math.mod",
    "pow": "std.math.pow",
    "abs": "std.math.abs",
    "negate": "std.math.negate",
    "inc": "std.math.inc",
    "dec": "std.math.dec",
    "clamp": "std.math.clamp",
    "round": "std.math.round",
    "floor": "std.math.floor",
    "ceil": "std.math.ceil",
    "compare": "std.logic.compare",
    "between": "std.logic.between",
    "xor": "std.logic.xor",
    "json_type": "std.type.json_type",
    "is_null": "std.type.is_null",
    "is_bool": "std.type.is_bool",
    "is_boolean": "std.type.is_boolean",
    "is_number": "std.type.is_number",
    "is_integer": "std.type.is_integer",
    "is_string": "std.type.is_string",
    "is_list": "std.type.is_list",
    "is_array": "std.type.is_array",
    "is_dict": "std.type.is_dict",
    "is_object": "std.type.is_object",
    "has_key": "std.object.has_key",
    "get": "std.object.get",
    "get_in": "std.object.get_in",
    "get_or": "std.object.get_or",
    "has_path": "std.object.has_path",
    "len": "std.collection.len",
    "count": "std.collection.count",
    "first": "std.collection.first",
    "rest": "std.collection.rest",
    "last": "std.collection.last",
    "nth": "std.collection.nth",
    "trim": "std.string.trim",
    "lower": "std.string.lower",
    "upper": "std.string.upper",
    "split": "std.string.split",
    "join": "std.string.join",
    "map": "std.collection.map",
    "filter": "std.collection.filter",
    "reject": "std.collection.reject",
    "find": "std.collection.find",
    "reduce": "std.collection.reduce",
    "partition": "std.collection.partition",
    "group_by": "std.collection.group_by",
    "uniq_by": "std.collection.uniq_by",
    "flatten": "std.collection.flatten",
    "concat": "std.collection.concat",
    "append": "std.collection.append",
    "prepend": "std.collection.prepend",
    "take": "std.collection.take",
    "drop": "std.collection.drop",
    "slice": "std.collection.slice",
    "reverse": "std.collection.reverse",
    "zip": "std.collection.zip",
    "zip_with": "std.collection.zip_with",
    "range": "std.math.range",
    "repeat": "std.collection.repeat",
    "any": "std.collection.any",
    "all": "std.collection.all",
    "none": "std.collection.none",
    "is_empty": "std.collection.is_empty",
    "distinct": "std.collection.distinct",
    "sort": "std.collection.sort",
    "coalesce": "std.null.coalesce",
    "default_to": "std.null.default_to",
    "contains_all": "std.collection.contains_all",
    "contains_any": "std.collection.contains_any",
    "pluck": "std.object.pluck",
    "sort_by": "std.collection.sort_by",
    "keys": "std.object.keys",
    "values": "std.object.values",
    "entries": "std.object.entries",
    "merge": "std.object.merge",
    "merge_deep": "std.object.merge_deep",
    "assoc": "std.object.assoc",
    "dissoc": "std.object.dissoc",
    "pick": "std.object.pick",
    "omit": "std.object.omit",
    "keys_exact": "std.object.keys_exact",
    "keys_include": "std.object.keys_include",
    "keys_exclude": "std.object.keys_exclude",
    "prop_eq": "std.object.prop_eq",
    "where": "std.object.where",
    "compose": "std.fn.compose",
    "pipe": "std.fn.pipe",
    "identity": "std.fn.identity",
    "always": "std.fn.always",
    "replace": "std.string.replace",
    "pad_left": "std.string.pad_left",
    "pad_right": "std.string.pad_right",
    "sum": "std.math.sum",
    "min": "std.math.min",
    "max": "std.math.max",
    "matches_all": "std.string.matches_all",
    "union": "std.set.union",
    "intersection": "std.set.intersection",
    "difference": "std.set.difference",
    "symmetric_difference": "std.set.symmetric_difference",
    "is_subset": "std.set.is_subset",
    "is_superset": "std.set.is_superset",
    "set_equals": "std.set.set_equals",
    "json_parse": "std.json.parse",
    "json_stringify": "std.json.stringify",
    "schema_match": "std.schema.match",
    "schema_errors": "std.schema.errors",
    "ops_fs_path_normalize": "ops.fs.path.normalize",
    "ops_fs_path_join": "ops.fs.path.join",
    "ops_fs_path_split": "ops.fs.path.split",
    "ops_fs_path_dirname": "ops.fs.path.dirname",
    "ops_fs_path_basename": "ops.fs.path.basename",
    "ops_fs_path_extname": "ops.fs.path.extname",
    "ops_fs_path_stem": "ops.fs.path.stem",
    "ops_fs_path_is_abs": "ops.fs.path.is_abs",
    "ops_fs_path_has_ext": "ops.fs.path.has_ext",
    "ops_fs_path_change_ext": "ops.fs.path.change_ext",
    "ops_fs_file_exists": "ops.fs.file.exists",
    "ops_fs_file_is_file": "ops.fs.file.is_file",
    "ops_fs_file_is_dir": "ops.fs.file.is_dir",
    "ops_fs_file_size_bytes": "ops.fs.file.size_bytes",
    "ops_fs_file_path": "ops.fs.file.path",
    "ops_fs_file_name": "ops.fs.file.name",
    "ops_fs_file_parent": "ops.fs.file.parent",
    "ops_fs_file_ext": "ops.fs.file.ext",
    "ops_fs_file_get": "ops.fs.file.get",
    "and": "std.logic.and",
    "or": "std.logic.or",
    "not": "std.logic.not",
}

STD_TO_FLAT: Final[dict[str, str]] = {v: k for k, v in FLAT_TO_STD.items()}


def namespace_index() -> dict[str, set[str]]:
    out: dict[str, set[str]] = {}
    for fq in STD_TO_FLAT:
        parts = fq.split(".")
        ns = ".".join(parts[:-1])
        out.setdefault(ns, set()).add(parts[-1])
    return out
